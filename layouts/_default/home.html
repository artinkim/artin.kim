{{ define "main" }}
<div class="home-container animate">
    <!-- Title Section at Top -->
    <div class="title-section">
        <!-- H1 is initially empty, JS will add spans -->
        <h1 class="primary-anim"></h1>
        {{ with site.Menus.main }}
        <nav class="menu inline animate">
            {{ range . }}
            <div class="menu-item">
                <a class="inactive nav-link-text {{ .Name }}" href="{{ .URL }}" data-text="{{ .Name }}"></a>
            </div>
            {{ end }}
        </nav>
        {{ end }}
    </div>

    <!-- Two Column Layout Below -->
    <div class="two-column-layout">
        <!-- Image moved outside and before the sections, positioned absolutely -->
        <img src="/img/artin_headshot.jpg" alt="Profile picture" class="profile-image-absolute">

        <!-- About Me Section -->
        <section class="about-section">
            <h2>About Me</h2>
            <p>
            I'm a Machine Learning Researcher and Software Engineer.
            My interests are wide and varied, but I'm currently most interested in:
            <ul style="font-size: 1.3rem; line-height: 1.8;">
                <li>Mechanistic Interpretability</li>
                <li>ML Systems</li>
                <li>Reinforcement Learning</li>
                <li>Singular Learning Theory, Double Decent, and Grokking </li>
            </ul>
            In my free time, I enjoy?
            </p>
        </section>
        
        <!-- Highlights Section -->
        <section class="highlights-section">
            <h2>Highlights</h2>
            <div class="highlights-grid">
                <!-- Projects Highlight -->
                <div class="highlight-card">
                    <div>
                        <h3>Snake AI</h3>
                        <p></p>2023</p>
                        <p>An ongoing project exploring real-time path tracing techniques using the Vulkan API and GLSL compute shaders.</p>
                    </div>
                    <a href="/projects/real-time-ray-tracer/" class="highlight-link">View Project →</a>
                </div>
                
                <!-- Highlighted Blog Post -->
                <div class="highlight-card">
                    <div>
                        <h3>Blog: Optimizing Shader Performance</h3>
                        <p>2023</p>
                        <p>A deep dive into common pitfalls and effective strategies for writing high-performance GLSL shaders for modern GPUs.</p>
                    </div>
                    <a href="/blog/optimizing-shader-performance/" class="highlight-link">Read Post →</a>
                </div>
                
                <!-- Highlighted Publication -->
                <div class="highlight-card">
                    <div>
                        <h3>Publication: Novel GI Technique</h3>
                        <p>2024</p>
                        <p>Details on a new method for approximating global illumination in dynamic scenes, published in ACM Transactions on Graphics.</p>
                    </div>
                    <a href="/publications/novel-gi-technique/" class="highlight-link">See Publication →</a>
                </div>
                
                <!-- Highlighted Video -->
                <div class="highlight-card">
                    <div>
                        <h3>Video: Intro to Compute Shaders</h3>
                        <p>2020</p>
                        <p>A beginner-friendly tutorial explaining the fundamentals of GPU compute shaders and how to leverage them for general-purpose tasks.</p>
                    </div>
                    <a href="/videos/intro-to-compute-shaders/" class="highlight-link">Watch Video →</a>
                </div>
            </div>
        </section>
    </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const homeContainer = document.querySelector('.home-container');
    const titleSection = document.querySelector('.title-section');
    const titleH1 = document.querySelector('.title-section h1');
    const navMenu = document.querySelector('.title-section nav.menu');
    const twoColumnLayout = document.querySelector('.two-column-layout');
    const profileImg = document.querySelector('.profile-image-absolute');
    const aboutSection = document.querySelector('.about-section');
    const highlightsSection = document.querySelector('.highlights-section');

    // --- Config ---
    const targetTitle = "{{ site.Title | default "Default Title" }}"; // Get title from Hugo
    const characterPool = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&*";
    const scrambleUpdateInterval = 50; // ms between character changes
    const scrambleDurationPerChar = 700; // ms each character scrambles
    const scrambleStaggerDelay = 80; // ms delay between start of each char scramble
    const movementStartDelay = 0; // ms after load before movement starts
    const scrambleStartDelayAfterMovement = 0; // ms after movement starts before scrambling begins
    const navTypingStartDelayAfterMovement = 300; // ms after movement starts before nav typing begins

    // --- Setup Title Spans ---
    const titleSpans = [];
    if (titleH1 && targetTitle) {
        titleH1.textContent = ''; // Clear H1
        for (let i = 0; i < targetTitle.length; i++) {
            const span = document.createElement('span');
            span.className = 'char-slot';
            // Use non-breaking space for layout, especially for actual spaces
            span.innerHTML = '&nbsp;';
            titleH1.appendChild(span);
            titleSpans.push(span);
        }
    }

    // --- Scramble Function ---
    function scrambleCharacter(spanElement, targetChar, duration) {
        let startTime = Date.now();
        let intervalId = setInterval(() => {
            const randomChar = characterPool[Math.floor(Math.random() * characterPool.length)];
            spanElement.textContent = randomChar;
            if (Date.now() - startTime >= duration) {
                clearInterval(intervalId);
                // Use innerHTML for spaces to ensure they render correctly
                spanElement.innerHTML = (targetChar === ' ') ? '&nbsp;' : targetChar;
            }
        }, scrambleUpdateInterval);
    }

    // --- Prepare Nav Links for JS Typewriter (Existing Method) ---
    const navLinks = navMenu ? Array.from(navMenu.querySelectorAll('.nav-link-text')) : [];
    const linkData = navLinks.map(link => {
        const text = link.getAttribute('data-text');
        link.textContent = ''; // Clear initial text
        return { element: link, text: text, currentLength: 0 };
    });
    let typedChars = 0;
    let currentLinkIndex = 0;
    const typingSpeed = 40; // Milliseconds per character for nav

    // --- JS Typewriter Function for Nav ---
    function typeCharacter() {
        if (currentLinkIndex < linkData.length) {
            const currentData = linkData[currentLinkIndex];
            if (currentData.currentLength < currentData.text.length) {
                currentData.element.textContent += currentData.text[currentData.currentLength];
                currentData.currentLength++;
                typedChars++;
                setTimeout(typeCharacter, typingSpeed);
            } else {
                currentLinkIndex++;
                typeCharacter();
            }
        }
    }


    // Ensure elements exist before proceeding (simplified fallback)
    if (!homeContainer || !titleSection || !titleH1 || !navMenu || !twoColumnLayout || !profileImg || !aboutSection || !highlightsSection) {
        console.error("Animation elements not found!");
        if(titleH1) titleH1.textContent = targetTitle; // Show final title immediately
        if(navMenu) { // Show nav immediately
             navMenu.classList.add('visible');
             linkData.forEach(data => data.element.textContent = data.text);
        }
        // Make other sections visible
        if(twoColumnLayout) twoColumnLayout.style.opacity = 1;
        if(profileImg) profileImg.classList.add('visible');
        if(aboutSection) aboutSection.classList.add('visible');
        if(highlightsSection) highlightsSection.classList.add('visible');
        return;
    }


    // --- Animation Sequence ---

    // Define Glitch parameters earlier for use in Step 2
    const glitchCharIndex = 3;           // Index of the character to change ('i' in "Artin")
    const glitchWrongChar = 'e';         // The character to initially show incorrectly ('e')
    const glitchCorrectChar = targetTitle[glitchCharIndex]; // The final correct char ('i')

    // 1. Start Upward Movement after a delay
    const movementStartTime = Date.now() + movementStartDelay;
    setTimeout(() => {
        titleSection.classList.add('move-to-top');
        homeContainer.classList.add('layout-final');
    }, movementStartDelay);

    // 2. Start Staggered Title Scramble *after* movement begins
    titleSpans.forEach((span, index) => {
        const charStartTime = movementStartDelay + scrambleStartDelayAfterMovement + (index * scrambleStaggerDelay);
        setTimeout(() => {
            // Start the scramble to the CORRECT character
            scrambleCharacter(span, targetTitle[index], scrambleDurationPerChar);

            // *** NEW: If this is the character to glitch, schedule the incorrect char display ***
            if (index === glitchCharIndex) {
                const incorrectCharDisplayTime = charStartTime + scrambleDurationPerChar + 10; // 10ms after scramble ends
                setTimeout(() => {
                    // Check if the span still exists (safety)
                    if (titleSpans[glitchCharIndex]) {
                         titleSpans[glitchCharIndex].textContent = glitchWrongChar;
                    }
                }, incorrectCharDisplayTime);
            }
        }, charStartTime);
    });

    // 3. Start Nav Fade/Type *after* movement begins
    const navStartTime = movementStartDelay + navTypingStartDelayAfterMovement;
    setTimeout(() => {
        navMenu.classList.add('visible');
        typeCharacter();
    }, navStartTime);

    // 4. Make Two-Column Layout Visible (relative to movement start)
    const layoutVisibleTime = movementStartDelay + 100; // Show shortly after movement starts
     setTimeout(() => {
        twoColumnLayout.classList.add('visible');
    }, layoutVisibleTime);

    // 5. Fade in Lower Content (After movement animation finishes)
    const movementDuration = 700; // Matches CSS transform duration for .title-section
    // Calculate based on actual movement start time
    const contentFadeInTime = movementStartDelay + movementDuration + 0;
    setTimeout(() => {
        profileImg.classList.add('visible');
        aboutSection.classList.add('visible');
        highlightsSection.classList.add('visible');
    }, contentFadeInTime);

    // 6. Glitch Correction after everything settles
    const glitchCorrectionDelayAfterContent = 1800; // 1 second after content fades in
    const cursorVisibleDuration = 750; // How long cursor stays after wrong char
    const deletePauseDuration = 250;   // Pause after deleting wrong char
    const typePauseDuration = 350;     // Pause after typing correct char (before cursor disappears)

    // Ensure the index is valid before setting timeout
    if (glitchCharIndex >= 0 && glitchCharIndex < titleSpans.length && glitchCorrectChar) {
        const glitchCorrectionStartTime = contentFadeInTime + glitchCorrectionDelayAfterContent;

        setTimeout(() => {
            const targetSpan = titleSpans[glitchCharIndex];
            if (targetSpan) {
                // --- Start Correction Sequence ---

                // 1. Add Cursor next to wrong character ('e')
                targetSpan.innerHTML = glitchWrongChar + '<span class="glitch-cursor"></span>';

                // 2. Wait, then Delete wrong character ('e') (leaving cursor)
                setTimeout(() => {
                    targetSpan.innerHTML = '<span class="glitch-cursor"></span>'; // Just the cursor

                    // 3. Wait, then Type correct character ('i') (with cursor)
                    setTimeout(() => {
                        // Use innerHTML for spaces
                        const correctContent = (glitchCorrectChar === ' ') ? '&nbsp;' : glitchCorrectChar;
                        targetSpan.innerHTML = correctContent + '<span class="glitch-cursor"></span>';

                        // 4. Wait, then Remove cursor
                        setTimeout(() => {
                            targetSpan.innerHTML = correctContent; // Final correct character ('i')
                        }, typePauseDuration);

                    }, deletePauseDuration);

                }, cursorVisibleDuration);
            }
        }, glitchCorrectionStartTime);
    }


    // --- Image Click Handler (Keep existing logic) ---
    if (profileImg) {
        profileImg.addEventListener('click', function() {
          // Restore the modal creation code:
          const modal = document.createElement('div');
          modal.style.position = 'fixed';
          modal.style.top = '0';
          modal.style.left = '0';
          modal.style.width = '100%';
          modal.style.height = '100%';
          modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
          modal.style.display = 'flex';
          modal.style.justifyContent = 'center';
          modal.style.alignItems = 'center';
          modal.style.zIndex = '1000'; // Ensure modal is on top
          modal.style.cursor = 'pointer';

          const largeImg = document.createElement('img');
          largeImg.src = '/img/artin_headshot_full.jpg';
          largeImg.style.maxHeight = '90vh';
          largeImg.style.maxWidth = '90vw';
          largeImg.style.borderRadius = '0.5rem';
          largeImg.style.cursor = 'default';

          largeImg.addEventListener('click', function(event) {
            event.stopPropagation();
          });

          modal.addEventListener('click', function() {
            document.body.removeChild(modal);
          });

          modal.appendChild(largeImg);
          document.body.appendChild(modal);
        });
    }
  });
</script>
{{ end }}